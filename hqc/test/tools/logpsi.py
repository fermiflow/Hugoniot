import jax
import jax.numpy as jnp

from tools.utils import logdet_matmul

def make_logpsi_hf(hf_orbitals):
    """
        Make the logpsi electron wavefunction.
        hf_orbitals is a static function generated by hf.
        kpt is fixed at gamma point.
    """

    def logpsi(x, s, mo_coeff):
        """
            Generic function that computes ln Psi(x) given momenta `k` and proton position
        `s`, a set of electron coordinates `x`
        INPUT:
            x: (n, dim)     
            s: (n, dim)
            mo_coeff: coefficient of hf orbitals on atomic orbitals (n_ao, n_mo)
        OUTPUT:
            a single complex number ln Psi(x), given in the form of a 2-tuple (real, imag).
        """
        D_up, D_dn =  hf_orbitals(s, x, mo_coeff)
        #phase, logabsdet = logdet_matmul([D_up[None, :, :], D_dn[None, :, :]])
        #log_phi = logabsdet + jnp.log(phase)
        sign_alpha, logabsdet_alpha = jnp.linalg.slogdet(D_up)
        sign_beta, logabsdet_beta = jnp.linalg.slogdet(D_dn)
        sign = sign_alpha * sign_beta
        logabsdet = logabsdet_alpha + logabsdet_beta
        log_phi = jnp.log(sign + 0.j) + logabsdet
        return jnp.stack([log_phi.real, log_phi.imag])

    return logpsi

def make_logpsi2(logpsi):
    
    def logpsi2(x, s, mo_coeff):
        """
            logp = logpsi + logpsi* = 2 Re logpsi
        Input:
            x: (n, dim)
            s: (n, dim)
            mo_coeff: (n_ao, n_mo)
        Output:
            logp: float
        """
        return 2* logpsi(x, s, mo_coeff)[0]
    
    return logpsi2

def make_logpsi_grad_laplacian(logpsi):

    def logpsi_grad_laplacian(x, s, mo_coeff):
        """
            Computes the gradient and laplacian of logpsi w.r.t. electron coordinates x.
        The final result is in complex form.

        Relevant dimensions: (after vmapped)

        INPUT:
            x: (n, dim)  s: (n, dim)
        OUTPUT:
            grad: (n, dim)   laplacian: float
        """

        grad = jax.jacrev(logpsi)(x, s, mo_coeff)
        grad = grad[0] + 1j * grad[1]

        n, dim = x.shape
        x_flatten = x.reshape(-1)
        grad_logpsi = jax.jacrev(lambda x: logpsi(x.reshape(n, dim), s, mo_coeff))

        def _laplacian(x):
            def body_fun(i, val):
                _, tangent = jax.jvp(grad_logpsi, (x,), (eye[i],))
                return val + tangent[0, i] + 1j * tangent[1, i]
            eye = jnp.eye(x.shape[0])
            laplacian = jax.lax.fori_loop(0, x.shape[0], body_fun, 0.+0.j)
            return laplacian

        laplacian = _laplacian(x_flatten)

        return grad, laplacian

    return logpsi_grad_laplacian

def make_logpsi_hf_kpt(hf_orbitals):
    """
        Make the logpsi electron wavefunction.
        hf_orbitals is a static function generated by hf.
    """

    def logpsi(x, s, mo_coeff, kpt):
        """
            Generic function that computes ln Psi(x) given momenta `k` and proton position
        `s`, a set of electron coordinates `x`
        INPUT:
            x: (n, dim)     
            s: (n, dim)
            mo_coeff: coefficient of hf orbitals on atomic orbitals (n_ao, n_mo)
            kpt: (3,) k-point. 1BZ: (-pi/L/rs, pi/L/rs)
        OUTPUT:
            a single complex number ln Psi(x), given in the form of a 2-tuple (real, imag).
        """
        D_up, D_dn =  hf_orbitals(s, x, mo_coeff, kpt)
        #phase, logabsdet = logdet_matmul([D_up[None, :, :], D_dn[None, :, :]])
        #log_phi = logabsdet + jnp.log(phase)
        sign_alpha, logabsdet_alpha = jnp.linalg.slogdet(D_up)
        sign_beta, logabsdet_beta = jnp.linalg.slogdet(D_dn)
        sign = sign_alpha * sign_beta
        logabsdet = logabsdet_alpha + logabsdet_beta
        log_phi = jnp.log(sign + 0.j) + logabsdet
        return jnp.stack([log_phi.real, log_phi.imag])

    return logpsi

def make_logpsi2_kpt(logpsi):
    
    def logpsi2(x, s, mo_coeff, kpt):
        """
            logp = logpsi + logpsi* = 2 Re logpsi
        Input:
            x: (n, dim)
            s: (n, dim)
            mo_coeff: (n_ao, n_mo)
            kpt: (3,) k-point. 1BZ: (-pi/L/rs, pi/L/rs)
        Output:
            logp: float
        """
        return 2* logpsi(x, s, mo_coeff, kpt)[0]
    
    return logpsi2

def make_logpsi_grad_laplacian_kpt(logpsi):

    def logpsi_grad_laplacian(x, s, mo_coeff, kpt):
        """
            Computes the gradient and laplacian of logpsi w.r.t. electron coordinates x.
        The final result is in complex form.

        Relevant dimensions: (after vmapped)

        INPUT:
            x: (n, dim)  
            s: (n, dim)
            mo_coeff: (n_ao, n_mo)
            kpt: (3,) k-point. 1BZ: (-pi/L/rs, pi/L/rs)
        OUTPUT:
            grad: (n, dim)   laplacian: float
        """

        grad = jax.jacrev(logpsi)(x, s, mo_coeff, kpt)
        grad = grad[0] + 1j * grad[1]

        n, dim = x.shape
        x_flatten = x.reshape(-1)
        grad_logpsi = jax.jacrev(lambda x: logpsi(x.reshape(n, dim), s, mo_coeff, kpt))

        def _laplacian(x):
            def body_fun(i, val):
                _, tangent = jax.jvp(grad_logpsi, (x,), (eye[i],))
                return val + tangent[0, i] + 1j * tangent[1, i]
            eye = jnp.eye(x.shape[0])
            laplacian = jax.lax.fori_loop(0, x.shape[0], body_fun, 0.+0.j)
            return laplacian

        laplacian = _laplacian(x_flatten)

        return grad, laplacian

    return logpsi_grad_laplacian